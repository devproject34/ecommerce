function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
import EventEmitter from 'eventemitter3';
import fs from 'fs';
import path from 'path';
import getNextTickFunction from './getNextTickFunction.js';
var config = {};
export function configure(_ref) {
  var initSqlJs = _ref.initSqlJs,
    wasmFileBaseUrl = _ref.wasmFileBaseUrl;
  config.initSqlJs = initSqlJs;
  config.wasmFileBaseUrl = wasmFileBaseUrl;
}

// `sqlite3`'s `Database` interface:
// https://github.com/TryGhost/node-sqlite3/blob/master/lib/sqlite3.d.ts
//
// Extends `EventEmitter` to mimick `sqlite3`'s `Database` behavior.
// Only emits a few events:
// * "open"
// * "close"
// * "error"
// Doesn't emit events:
// * "trace"
// * "profile"
// * "change"
//
var Database = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Database, _EventEmitter);
  // `filename: string` is a path to the file in which the data will be stored. Example: ":memory:".
  // `mode?: number` is an optional access mode: read-only, read-write, etc.
  // `callback?: function` gets called after the database is ready, or if there was an error.
  function Database(filename, mode, callback) {
    var _this;
    _classCallCheck(this, Database);
    _this = _callSuper(this, Database);
    if (typeof mode === 'function') {
      callback = mode;
      mode = undefined;
    }

    // Since `sqlite3`'s `Database` is declared to be an `EventEmitter`,
    // developers will be (appropriately) using it as:
    //
    // const database = new Database(filename, callback)
    // database.on('eventName', eventHandler)
    //
    // And they'll be expecting the `callback` to always be fired after those `.on()` calls
    // and never before them.
    // If the `callback` was called here as is, i.e. as simply `callback()`,
    // it would've been called before those `.on()` event listeners have been set up
    // resulting in a potential loss of some of the events.
    //
    // So the name of this function signals that `callback()` should always be called
    // "asynchronously" rather than "synchronously".
    //
    var callCallbackAsynchronously = function callCallbackAsynchronously(error) {
      // `process.nextTick()` workaround is not used in this code, the reasons being:
      // * It only works on server side.
      // * The `initSqlJs()` function already introduces an "asynchronicity" of its own.
      callback(error);
    };

    // "By default, sql.js uses wasm, and thus needs to load a `.wasm` file
    //  in addition to the javascript library. You can find this file in
    //  `./node_modules/sql.js/dist/sql-wasm.wasm` after installing sql.js from npm,
    //  and instruct your bundler to add it to your static assets or load it from a CDN".
    //
    // "Then use the locateFile property of the configuration object passed to
    //  `initSqlJs` to indicate where the file is. If you use an asset builder
    //  such as webpack, you can automate this".
    //
    // "Required to load the wasm binary asynchronously.
    //  Of course, you can host it wherever you want".
    //
    // A client application could define the "base" URL of a WASM file either way:
    // * By calling `.config()` static function with a `wasmFileBaseUrl` parameter.
    // * By setting `window.SQL_JS_WASM_FILE_BASE_URL` global variable.
    //
    var sqlJsWasmFileBaseUrl = config.wasmFileBaseUrl || (typeof window !== 'undefined' ? window.SQL_JS_WASM_FILE_BASE_URL : undefined);
    var isNodeJs = typeof process !== 'undefined' && process.release.name === 'node';
    var onError = function onError(error) {
      if (callback) {
        // Call the `callback`.
        callCallbackAsynchronously(error);
      } else {
        // "If no `callback` is provided and an error occurred,
        // an `error` event with the error object as the only parameter
        // will be emitted".
        _this.emit('error', error);
      }
    };
    var onSuccess = function onSuccess() {
      // "If opening succeeded, an `open` event with no parameters is emitted,
      //  regardless of whether a `callback` was provided or not".
      _this.emit('open');
      // Call the `callback`.
      if (callback) {
        callCallbackAsynchronously(null);
      }
    };
    if (!isNodeJs) {
      if (!sqlJsWasmFileBaseUrl) {
        return _possibleConstructorReturn(_this, onError(new Error('The base URL for `sql.js` `*.wasm` files is not configured')));
      }
      if (sqlJsWasmFileBaseUrl[sqlJsWasmFileBaseUrl.length - 1] !== '/') {
        return _possibleConstructorReturn(_this, onError(new Error('The base URL for `sql.js` `*.wasm` files must end with a "/"')));
      }
    }
    var initSqlJsPromise = config.initSqlJs ? Promise.resolve(config.initSqlJs) : isNodeJs ? import('sql.js').then(function (_) {
      return _["default"];
    }) : typeof window !== 'undefined' ? Promise.resolve(window.initSqlJs) : Promise.reject(new Error('`window` is not defined'));
    initSqlJsPromise.then(function (initSqlJs) {
      if (!initSqlJs) {
        return onError(new Error('`sql.js` not found'));
      }
      // Initialize `sql.js` — fetch the ".wasm" file and run it.
      return initSqlJs({
        // "You can omit `locateFile` when running in Node.js".
        //
        // When `locateFile` parameter is not omitted in Node.js, it throws an error:
        // "Error: ENOENT: no such file or directory, open 'https:\sql.js.org\dist\sql-wasm.wasm'".
        //
        // May be somehow related: https://github.com/sql-js/sql.js/issues/528
        //
        locateFile: isNodeJs ? undefined : function (filename) {
          return "".concat(sqlJsWasmFileBaseUrl).concat(filename);
        }
      }).then(function (SQL) {
        // Create a database.
        const databaseFile = path.join(process.cwd(), 'database.sqlite');
        if (fs.existsSync(databaseFile)) {
          console.log('Loaded db from database.sqlite');
          const fileBuffer = fs.readFileSync(databaseFile);
          _this.database = new SQL.Database(fileBuffer);
        } else {
          console.log('Loaded fresh db');
          _this.database = new SQL.Database();
        }

        onSuccess();
      }, onError);
    }, onError);
    return _this;
  }

  // "Closes the database.
  //  `callback` (optional): If provided, this function will be called when the database
  //  was closed successfully or when an error occurred. The first argument is an `error` object.
  //  When it is null, closing succeeded. If no `callback` is provided and an error occurred,
  //  an "error" event with the `error` object as the only parameter will be emitted on the database object.
  //  If closing succeeded, a "close" event with no parameters is emitted, regardless of whether
  //  a `callback` was provided or not.
  _createClass(Database, [{
    key: "close",
    value: function close(callback) {
      this.database.close();
      this.emit('close');
      if (callback) {
        callback(null);
      }
    }

    // "Set a configuration option for the database. Valid options are:
    //  * Tracing & profiling
    //    * trace: provide a function callback as a value. Invoked when an SQL statement executes, with a rendering of the statement text.
    //    * profile: provide a function callback. Invoked every time an SQL statement executes.
    //  * busyTimeout: provide an integer as a value. Sets the busy timeout".
  }, {
    key: "configure",
    value: function configure(option, value) {}

    // "Loads a compiled SQLite extension into the database connection object".
  }, {
    key: "loadExtension",
    value: function loadExtension(path, callback) {
      throw new Error('`loadExtension()` is not supported');
    }

    // "Allows the user to interrupt long-running queries.
    //  Wrapper around `sqlite3_interrupt` and causes other data-fetching functions
    //  to be passed an `error` with `code = sqlite3.INTERRUPT`".
  }, {
    key: "interrupt",
    value: function interrupt() {
      // This method is not implemented because `sql.js` methods are "synchronous" ("blocking").

      // this.database.exec('select interrupt();')
    }

    // There're no docs on this method.
    // I guess it calls the `callback` after all queries have finished.
  }, {
    key: "wait",
    value: function wait(callback) {
      // `sql.js` methods are "synchronous" ("blocking")
      // so the `wait()` method doesn't really make sense here.
      // It just calls the `callback`.
      if (callback) {
        callback(null);
      }
    }

    // https://stackoverflow.com/questions/41949724/how-does-db-serialize-work-in-node-sqlite3
    // "Each command inside the `serialize()`'s `func` function is guaranteed to finish executing
    //  before the next one starts".
  }, {
    key: "serialize",
    value: function serialize(func) {
      func();
    }

    // https://www.sqlitetutorial.net/sqlite-nodejs/statements-control-flow/
    // "The `serialize()` method allows you to execute statements in serialized mode,
    //  while the `parallelize()` method executes the statements in parallel".
  }, {
    key: "parallelize",
    value: function parallelize(func) {
      func();
    }

    // "Runs the SQL query with the specified parameters and calls the `callback` afterwards.
    //  It does not retrieve any result data".
  }, {
    key: "run",
    value: function run() {
      var _this2 = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var _getRunArguments = getRunArguments(args),
        query = _getRunArguments.query,
        unboundCallback = _getRunArguments.callback,
        parameters = _getRunArguments.parameters;

      // "The context of the `callback` function (the `this` object inside the function)
      //  is the statement object".
      //
      // "If execution was successful, the this object will contain two properties named
      //  `lastID` and `changes` which contain the value of the last inserted row ID
      //  and the number of rows affected by this query respectively".
      //
      var statement = {};
      var callback = unboundCallback;
      if (callback) {
        callback = callback.bind(statement);
      }
      try {
        // Run the query.
        this.database.run(query, parameters);

        // Just a simple "lame" SQL operation type detection.
        var isInsert = /^\s*insert\s+/i.test(query);
        var isUpdate = /^\s*update\s+/i.test(query);
        var isDelete = /^\s*delete\s+/i.test(query);

        // Gets a value from the database.
        var getValue = function getValue(query) {
          var results = _this2.database.exec(query + ';');
          return results[0].values[0][0];
        };
        if (isInsert) {
          // The row ID of the most recent successful INSERT.
          statement.lastID = getValue('select last_insert_rowid()');
        }
        if (isInsert || isUpdate || isDelete) {
          // The number of rows modified, inserted or deleted by the most recently completed
          // INSERT, UPDATE or DELETE statement.
          statement.changes = getValue('select changes()');
        }
        if (callback) {
          callCallbackAsynchronously(callback, null);
        }
      } catch (error) {
        if (callback) {
          callCallbackAsynchronously(callback, error);
        } else {
          // "When no `callback` is provided and an error occurs,
          //  an "error" event will be emitted".
          this.emit('error', error);
          // throw error
        }
      }

      // Returns `this` for method chaining.
      return this;
    }

    // "Runs the SQL query with the specified parameters and calls the `callback`
    //  with all result rows afterwards".
  }, {
    key: "all",
    value: function all() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var _getRunArguments2 = getRunArguments(args),
        query = _getRunArguments2.query,
        callback = _getRunArguments2.callback,
        parameters = _getRunArguments2.parameters;
      try {
        var results = [];
        this.database.each(query, parameters,
        // When a query has produced a result (only for `SELECT` queries).
        function (result) {
          results.push(result);
        },
        // When all queries have finished.
        function () {
          if (callback) {
            callCallbackAsynchronously(callback, null, results);
          }
        });
      } catch (error) {
        if (callback) {
          callCallbackAsynchronously(callback, error);
        } else {
          throw error;
        }
      }

      // Returns `this` for method chaining.
      return this;
    }

    // "Runs the SQL query with the specified parameters and calls the `callback`
    //  once for each result row".
  }, {
    key: "each",
    value: function each() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var _getRunArguments3 = getRunArguments(args),
        query = _getRunArguments3.query,
        callback = _getRunArguments3.callback,
        parameters = _getRunArguments3.parameters;
      try {
        var results = [];
        this.database.each(query, parameters,
        // When a query has produced a result (only for `SELECT` queries).
        function (result) {
          if (callback) {
            callCallbackAsynchronously(callback, null, result);
          }
        });
      } catch (error) {
        if (callback) {
          callCallbackAsynchronously(callback, error);
        } else {
          throw error;
        }
      }

      // Returns `this` for method chaining.
      return this;
    }
  }, {
    key: "get",
    value: function get() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      var _getRunArguments4 = getRunArguments(args),
        query = _getRunArguments4.query,
        callback = _getRunArguments4.callback,
        parameters = _getRunArguments4.parameters;
      try {
        var results = this.database.exec(query, parameters);

        // "If the result set is empty, the second parameter is `undefined`,
        //  otherwise it is an object containing the values for the first row.
        //  The property `names` correspond to the column names of the result set".
        //
        // I dunno if the `result` object is correct or not.
        // It's more of a "placeholder" implementation.
        //
        var result = results[0];
        if (callback) {
          callCallbackAsynchronously(callback, null, result);
        }
      } catch (error) {
        if (callback) {
          callCallbackAsynchronously(callback, error);
        } else {
          throw error;
        }
      }

      // Returns `this` for method chaining.
      return this;
    }

    // "Runs all SQL queries in the supplied string. No result rows are retrieved".
  }, {
    key: "exec",
    value: function exec(query, callback) {
      try {
        this.database.exec(query);
        if (callback) {
          callCallbackAsynchronously(callback, null);
        }
      } catch (error) {
        if (callback) {
          callCallbackAsynchronously(callback, error);
        } else {
          // "When no `callback` is provided and an error occurs,
          //  an "error" event will be emitted".
          this.emit('error', error);
          // throw error
        }
      }

      // Returns `this` for method chaining.
      return this;
    }

    // "Prepares the SQL statement and optionally binds the specified parameters
    //  and calls the callback when done. The function returns a Statement object."
  }, {
    key: "prepare",
    value: function prepare() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      var _getRunArguments5 = getRunArguments(args),
        query = _getRunArguments5.query,
        callback = _getRunArguments5.callback,
        parameters = _getRunArguments5.parameters;
      var statement = {};
      try {
        statement = this.database.prepare(query, parameters);
        if (callback) {
          callCallbackAsynchronously(callback, null);
        }
      } catch (error) {
        if (callback) {
          callCallbackAsynchronously(callback, error);
        } else {
          throw error;
        }
      }
      return statement;
    }
  }]);
  return Database;
}(EventEmitter);
export { Database as default };
var nextTick = getNextTickFunction();
function callCallbackAsynchronously(callback, error, result) {
  nextTick(function () {
    return callback(error, result);
  });
}
function getEnvVars() {
  if (typeof process !== 'undefined') {
    return process.env;
  }
}
function getRunArguments(args) {
  var query = args.shift();
  var parameters;
  var callback;

  // Sort out the arguments.
  if (args.length === 0) {
    parameters = [];
  } else {
    if (typeof args[args.length - 1] === 'function') {
      callback = args.pop();
    }
    parameters = args;
  }

  // If parameters were passed as an object then convert them to an object.
  if (parameters.length === 1) {
    if (parameters[0] !== null && _typeof(parameters[0]) === 'object') {
      parameters = parameters[0];
    }
  }
  return {
    query: query,
    parameters: parameters,
    callback: callback
  };
}
//# sourceMappingURL=Database.js.map